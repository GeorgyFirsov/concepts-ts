<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Concepts Closed Issues List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<table>
<tr>
  <td align="left">Date:</td>
  <td align="left">2016-03-01</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">C++ Extensions for Concepts</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Andrew Sutton &lt;<a href="mailto:asutton@uakron.edu">asutton@uakron.edu</a>&gt;</td>
</tr>
</table>
<h1>C++ Concepts Closed Issues List (Revision 2)</h1>
<p>Revised 2016-03-01 at 12:03:17 UTC</p>

  <p>Reference ISO/IEC TS 19217</p>
  <p>Also see:</p>
    <ul>
      <li><a href="ts-toc.html">Table of Contents</a> for all concepts issues.</li>
      <li><a href="ts-index.html">Index by Section</a> for all concepts issues.</li>
      <li><a href="ts-status.html">Index by Status</a> for all concepts issues.</li>
      <li><a href="ts-active.html">Concepts Active Issues List</a></li>
      <li><a href="ts-complete.html">Concepts Complete Issues List</a></li>
    </ul>

  <p>This document contains only concepts issues which have been closed
  by the Core Working Group as duplicates or not defects. That is,
  issues which have a status of <a href="ts-active.html#Dup">Dup</a> or
  <a href="ts-active.html#NAD">NAD</a>. See the <a href="ts-active.html">Concepts Active Issues List</a> active issues and more
  information. See the <a href="ts-complete.html">Concepts Complete Issues List</a> for issues considered
  accepted extensions.  The introductory material in that document also applies to
  this document.</p>

<h2>Revision History</h2>
<ul>
<li>R2: 2015-05-22 pre-Jacksonville mailing<ul>
<li><b>Summary:</b><ul>
<li>24 open issues, down by 4.</li>
<li>6 closed issues, up by 6.</li>
<li>30 issues total, up by 2.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 2 CWG issues: <a href="ts-active.html#29">29</a>, <a href="ts-active.html#30">30</a>.</li>
<li>Changed the following issue from EWG to CWG: <a href="ts-active.html#11">11</a>.</li>
<li>Changed the following 12 issues from New to CWG: <a href="ts-active.html#15">15</a>, <a href="ts-active.html#16">16</a>, <a href="ts-active.html#17">17</a>, <a href="ts-active.html#18">18</a>, <a href="ts-active.html#19">19</a>, <a href="ts-active.html#21">21</a>, <a href="ts-active.html#22">22</a>, <a href="ts-active.html#23">23</a>, <a href="ts-active.html#24">24</a>, <a href="ts-active.html#25">25</a>, <a href="ts-active.html#26">26</a>, <a href="ts-active.html#27">27</a>.</li>
<li>Changed the following 4 issues from New to EWG: <a href="ts-active.html#13">13</a>, <a href="ts-active.html#14">14</a>, <a href="ts-active.html#20">20</a>, <a href="ts-active.html#28">28</a>.</li>
<li>Changed the following 6 issues from EWG to NAD: <a href="ts-closed.html#2">2</a>, <a href="ts-closed.html#4">4</a>, <a href="ts-closed.html#5">5</a>, <a href="ts-closed.html#9">9</a>, <a href="ts-closed.html#10">10</a>, <a href="ts-closed.html#12">12</a>.</li>
</ul></li>
</ul>
</li>
</ul>

<h2>Closed Issues</h2>
<hr>
<h3><a name="2"></a>2. Allow concepts as class members</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#NAD">NAD</a>
 <b>Submitter:</b> FI <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-03-01</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems unfortunate that concepts cannot be declared as members of class
templates. This seemingly makes it impossible to define concepts for
constraining multiple template parameter packs (if concepts as static member
functions were possible, one could provide e.g. two packs so that the class
template gets the first pack and the member function template gets the
second. That can't be done with a namespace scope concept because multiple
packs in function templates require deduction, and concepts  don't take
arguments that could be deduced.). As an example, practical needs for such
constraining arise in standard library implementations, when constraining
the variadic converting constructors of  <code>std::tuple</code>.
</p>

<p>
Suggest opening an EWG issue.
</p>


<p><b>Rationale:</b></p>
EWG was neutral on this topic. Suggest a paper with rationale and wording.





<hr>
<h3><a name="4"></a>4. Exception constraints</h3>
<p><b>Section:</b> 5.1.4.3 [expr.prim.req.compound] <b>Status:</b> <a href="ts-active.html#NAD">NAD</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-03-01</p>
<p><b>View all other</b> <a href="ts-index.html#expr.prim.req.compound">issues</a> in [expr.prim.req.compound].</p>
<p><b>View all issues with</b> <a href="ts-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We believe that (generally speaking) the non throwing of exceptions is a
part of the runtime contract of a function, not something that should be
advertised in the type system outside a few very specific cases related to
move operations. As a <code>requires</code> expression is always free to invoke the
<code>noexcept</code> operator to produce a predicate, we believe that is sufficient
support for exception constraints in the language, and directly
supporting this additional term in the grammar would be harmful, encouraging
compile-time contracts taking away an important library implementer freedom.
As the TS is intended to provide feedback, we believe it would be better to
proceed without this, and see how much demand arises from using the
alternate form, and whether that alternate form alone is too cumbersome for
real world use.
</p>

<p>
Simplify the <i>compound-requirement</i>: term in 5.1.4.3:

<pre>
<code>
    { expression } <del>[noexcept]</del> [trailing-return-type]
</code>
</pre>

Strike 14.10.1.7.
</p>

<p>
Also see <a href="ts-closed.html#5">5</a> as it relates.
</p>

<p>
Suggest opening an EWG issue.
</p>


<p><b>Rationale:</b></p>
EWG was against dropping the <tt>noexcept</tt> keyword.





<hr>
<h3><a name="5"></a>5. Extending exception constraints</h3>
<p><b>Section:</b> 5.1.4.3 [expr.prim.req.compound] <b>Status:</b> <a href="ts-active.html#NAD">NAD</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-03-01</p>
<p><b>View all other</b> <a href="ts-index.html#expr.prim.req.compound">issues</a> in [expr.prim.req.compound].</p>
<p><b>View all issues with</b> <a href="ts-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we retain exception constraints, the optional `noexcept` specifier
should support the full range of the noexcept grammar.

Amend <i>compound-requirement</i>:
<pre>
<code>
    { expression } <del>[noexcept]</del> <ins>[noexcept-specification]</ins> [trailing-return-type]
</code>
</pre>
</p>

<p>
Also see <a href="ts-closed.html#4">4</a> as it relates.
</p>

<p>
Suggest opening an EWG issue.
</p>


<p><b>Rationale:</b></p>
EWG was against adding full exception specifications to compound requirements.





<hr>
<h3><a name="9"></a>9. Concern about terse notation</h3>
<p><b>Section:</b> 7.1.6.4.2 [dcl.spec.auto.constr] <b>Status:</b> <a href="ts-active.html#NAD">NAD</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-03-01</p>
<p><b>View all issues with</b> <a href="ts-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have a broad concern that the ambiguity for a reader between a
constrained function template without a template-introducer and a "regular"
function will make the language unnecessarily difficult to teach, read, and
maintain code. We note that a TS is the perfect vehicle to have an experiment
to establish if these concerns are real, but want to exercise caution as we
proceed, and be sure that there is a real feedback plan in place before
considering moving this feature from a TS and into a future standard.
</p>

<p>
Suggest opening an EWG issue.
</p>


<p><b>Rationale:</b></p>
EWG is against dropping the terse notation from the design of concepts.





<hr>
<h3><a name="10"></a>10. Redundant expressions of constraints</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#NAD">NAD</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-03-01</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.decl">active issues</a> in [temp.constr.decl].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are too many redundant ways to express the same set of requirements.
While each presents a reasonable use-case in isolation, the combined effect is
overwhelming.

Proposed solution: Review the overlapping syntaxes, and eliminate those
that add least value, or are least frequently used. This may mean shipping
the TS in close to its current form to obtain such feedback though.
</p>

<p>
Suggest opening an EWG issue.
</p>


<p><b>Rationale:</b></p>
The issue is too broadly stated. There is nothing specific for EWG to address
as an issue.





<hr>
<h3><a name="12"></a>12. Add same-type constraints for expressions</h3>
<p><b>Section:</b> 14.10.1.1 [temp.constr.conv] <b>Status:</b> <a href="ts-active.html#NAD">NAD</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-03-01</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.conv">issues</a> in [temp.constr.conv].</p>
<p><b>View all issues with</b> <a href="ts-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This paragraph introduces implicit conversion constraints to specify (via the
trailing-return-type notation <code>-></code>) that a constraint is satisfied iff an
expression <code>E</code> is convertible to a type <code>T</code>. It would be very useful to have
similar constraints that are satisfied iff <code>decltype(E)</code> is exactly the type
<code>T</code>.

Introduce new notation (e.g., <code>E => T</code>) to denote a constraint that is
satisfied iff the expression <code>E</code> has precisely the type <code>T</code>. Here is a
practical example of the utility of such a feature:

<pre>
<code>
    template &lt;typename T&gt;
    concept bool CopyAssignable = requires (T a, T b) {
      { a = b } => T const&amp;;
    };
</code>
</pre>
</p>

<p>
This is a proposal for an extension and is better addressed in EWG.
</p>


<p><b>Rationale:</b></p>
EWG is not in favor of adding this feature.





</body>
</html>
